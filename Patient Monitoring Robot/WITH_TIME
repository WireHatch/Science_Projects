/*
 * ESP32 Health Monitoring System - MAX30102 (MAX30105 Library)
 * Enhanced Three-Button Control System with Time Display
 *
 * Pin Connections:
 * DS18B20: Data -> GPIO4
 * MAX30102: SDA -> GPIO21, SCL -> GPIO22
 * LCD I2C: SDA -> GPIO21, SCL -> GPIO22
 * SERVO: Signal -> GPIO13
 * BUTTON_NEXT_STEP: GPIO15 (Initiate/Next Step)
 * BUTTON_RESTART: GPIO14 (Restart/Cancel)
 * BUTTON_DISPENSE: GPIO12 (Hold/Resume)
 */

// ===============================
// LIBRARY INCLUDES
// ===============================
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ESP32Servo.h>
#include "MAX30105.h"
#include "heartRate.h"
#include "spo2_algorithm.h"
#include <WiFi.h>
#include <time.h>

// ===============================
// WiFi CREDENTIALS - MODIFY HERE
// ===============================
const char* ssid = "Bohemian";
const char* password = "Guddu@123";

// ===============================
// NTP SERVER SETTINGS
// ===============================
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 6 * 3600;  // Bangladesh Time (GMT+6)
const int daylightOffset_sec = 0;

// ===============================
// CORE PARAMETERS & PIN DEFINITIONS
// ===============================
#define SERVO_PIN 13
#define COMPARTMENT_ANGLE_MORN 0
#define COMPARTMENT_ANGLE_NOON 45
#define COMPARTMENT_ANGLE_EVEN 90
#define COMPARTMENT_ANGLE_NIGHT 135
#define SERVO_REST_ANGLE 180 
#define SERVO_ROTATION_DELAY 1500
#define SERVO_PULSE_MIN 500
#define SERVO_PULSE_MAX 2400

#define DS18B20_PIN 4
#define I2C_SDA 21
#define I2C_SCL 22
#define BUTTON_NEXT_STEP 15    // Initiate/Next Step
#define BUTTON_RESTART 14       // Restart/Cancel
#define BUTTON_DISPENSE 12      // Hold/Resume

const unsigned long TEMP_MEASURE_TIME = 5000;
const unsigned long HR_MEASURE_TIME = 10000;
const unsigned long SPO2_MEASURE_TIME = 8000;
const unsigned long REPORT_DISPLAY_TIME = 8000;
const unsigned long DEBOUNCE_DELAY = 100;
const unsigned long FINGER_CHECK_INTERVAL = 2000; // Check for finger every 2s
const unsigned long STATE_TRANSITION_DELAY = 2000; // Delay between states

// ===============================
// SENSOR INITIALIZATION
// ===============================
LiquidCrystal_I2C lcd(0x27, 16, 2);
OneWire oneWire(DS18B20_PIN);
DallasTemperature sensors(&oneWire);
Servo pillServo;
MAX30105 particleSensor;

// ===============================
// MAX30102 SPECIFIC VARIABLES
// ===============================
const byte RATE_SIZE = 3;
byte rates[RATE_SIZE];
byte rateSpot = 0;
long lastBeat = 0;
float beatsPerMinute = 0.0;
int beatAvg = 0;
int irValue = 0;

// SpO2 Variables
int32_t spo2 = 0;
int8_t validSPO2 = 0;
int32_t heartRateSPO2 = 0;
int8_t validHeartRate = 0;

// ===============================
// GLOBAL STATE VARIABLES
// ===============================
float temperatureC = 0.0;
float temperatureF = 0.0;
int heartRate = 0;
int spO2Value = 0;
bool measurementsComplete = false;
unsigned long stateStartTime = 0;
unsigned long lastFingerCheck = 0;
bool isHeld = false;
bool measurementInProgress = false;
int currentCompartment = 0; 

// Sensor Status Flags
bool tempSensorOK = false;
bool hrSensorOK = false;
bool wifiConnected = false;
bool timeAvailable = false;

// Button State Variables
unsigned long lastButtonPressTime[3] = {0, 0, 0};

// ===============================
// CORE STATE MACHINE
// ===============================
enum SystemState {
  IDLE,
  SHOW_MENU,
  PLACE_FINGER_ON_SENSOR,
  INITIALIZING_MEASUREMENT,
  MEASURING_TEMPERATURE,
  MEASURING_PULSE,
  MEASURING_SPO2,
  SHOWING_REPORT,
  UPLOADING_DATA,
  AWAITING_CANCEL_CONFIRMATION
};

SystemState currentState = IDLE;
SystemState stateBeforeHold = IDLE; 

// ===============================
// FUNCTION DECLARATIONS
// ===============================
void updateLCD(const String &line1, const String &line2);
void initializeSensors();
void updateStateMachine();
void measureTemperature();
void measureHeartRate();
void measureSpO2();
String getCurrentTime();
void updateTimeOnIdleScreen();
void servoRotate(int angle);
void handleSerialCommands();
void handleButtonPresses();
void startProcess();
void nextStep();
void toggleHold();
void initiateRestart();
void confirmRestart();
void cancelRestart();
bool readButton(int pin, int index);
void showReport();
void checkFingerPresence();
void transitionWithDelay(SystemState nextState, const String &msg1, const String &msg2);
void spinner();

// ===============================
// BUTTON & DEBOUNCE FUNCTIONS
// ===============================
bool readButton(int pin, int index) {
  bool currentState = digitalRead(pin);
  
  if (currentState == LOW) {
    if ((millis() - lastButtonPressTime[index]) > DEBOUNCE_DELAY) {
      lastButtonPressTime[index] = millis();
      return true;
    }
  }
  if (currentState == HIGH) {
    lastButtonPressTime[index] = 0;
  }
  return false;
}

// ===============================
// LCD FUNCTIONS
// ===============================
void updateLCD(const String &line1, const String &line2) {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(line1);
  lcd.setCursor(0, 1);
  lcd.print(line2);
}

// ===============================
// SERVO/PILL FUNCTIONS
// ===============================
void servoRotate(int angle) {
  pillServo.write(angle);
  delay(SERVO_ROTATION_DELAY);
  pillServo.write(SERVO_REST_ANGLE);
}

// ===============================
// STATE TRANSITION HELPER
// ===============================
void transitionWithDelay(SystemState nextState, const String &msg1, const String &msg2) {
  updateLCD(msg1, msg2);
  delay(STATE_TRANSITION_DELAY);
  currentState = nextState;
  stateStartTime = millis();
}

// ===============================
// CONTROL & INPUT LOGIC
// ===============================
void startProcess() {
  if (currentState == IDLE || currentState == SHOW_MENU) {
    Serial.println("\n=== Starting Measurement Process ===");
    measurementInProgress = true;
    transitionWithDelay(PLACE_FINGER_ON_SENSOR, "Starting...", "Please wait");
  } else {
    Serial.println("Process already running.");
    updateLCD("Already Running", "Press BTN_B");
    delay(1500);
  }
}

void nextStep() {
  switch(currentState) {
    case IDLE:
    case SHOW_MENU:
      startProcess();
      break;
    case PLACE_FINGER_ON_SENSOR:
      if (irValue > 50000) {
        transitionWithDelay(INITIALIZING_MEASUREMENT, "Manual Start", "Initializing...");
      } else {
        updateLCD("No Finger!", "Place finger first");
        delay(1500);
      }
      break;
    case SHOWING_REPORT:
      currentState = IDLE;
      measurementInProgress = false;
      updateTimeOnIdleScreen();
      break;
    default:
      Serial.println("Next step not available");
      break;
  }
}

void toggleHold() {
  if (!measurementInProgress) {
    Serial.println("No active measurement to hold");
    updateLCD("No Active", "Measurement");
    delay(1500);
    return;
  }

  isHeld = !isHeld;
  if (isHeld) {
    stateBeforeHold = currentState;
    Serial.println("=== Process HELD ===");
    updateLCD("PROCESS HELD", "BTN_C: Resume");
  } else {
    currentState = stateBeforeHold;
    Serial.println("=== Process RESUMED ===");
    updateLCD("RESUMING...", "Please wait");
    delay(1500);
    stateStartTime = millis();
  }
}

void initiateRestart() {
  if (measurementInProgress) {
    Serial.println("=== Restart Requested ===");
    updateLCD("Confirm Restart?", "BTN_B: Yes");
    currentState = AWAITING_CANCEL_CONFIRMATION;
  } else {
    Serial.println("No active process to restart");
    updateLCD("No Active", "Process");
    delay(1500);
    currentState = IDLE;
  }
}

void confirmRestart() {
  if (currentState == AWAITING_CANCEL_CONFIRMATION) {
    Serial.println("=== RESTART CONFIRMED ===");
    updateLCD("Restarting...", "Please wait");
    delay(1500);
    
    measurementInProgress = false;
    isHeld = false;
    measurementsComplete = false;
    temperatureC = 0.0;
    heartRate = 0;
    spO2Value = 0;
    
    for (byte x = 0; x < RATE_SIZE; x++) rates[x] = 0;
    rateSpot = 0;
    beatAvg = 0;
    
    currentState = IDLE;
    stateStartTime = millis();
    updateLCD("System Reset", "Ready");
    delay(1500);
  }
}

void cancelRestart() {
  if (currentState == AWAITING_CANCEL_CONFIRMATION) {
    Serial.println("Restart cancelled, resuming...");
    updateLCD("Cancelled", "Resuming...");
    delay(1000);
    currentState = stateBeforeHold;
    stateStartTime = millis();
  }
}

void handleSerialCommands() {
  if (Serial.available()) {
    String command = Serial.readStringUntil('\n');
    command.trim();
    command.toUpperCase();
    Serial.print("Command: ");
    Serial.println(command);

    if (command == "S" || command == "START" || command == "NEXT") {
      nextStep();
    } else if (command == "H" || command == "HOLD") {
      toggleHold();
    } else if (command == "R" || command == "RESTART") {
      initiateRestart();
    } else if (command == "Y" && currentState == AWAITING_CANCEL_CONFIRMATION) {
      confirmRestart();
    } else if (command == "N" && currentState == AWAITING_CANCEL_CONFIRMATION) {
      cancelRestart();
    } else {
      Serial.println("Commands: S(tart), H(old), R(estart)");
    }
  }
}

void handleButtonPresses() {
  // Button 1 (GPIO15) - NEXT STEP / INITIATE
  if (readButton(BUTTON_NEXT_STEP, 0)) {
    Serial.println("BTN_A (NEXT_STEP) pressed");
    nextStep();
    return;
  }
  
  // Button 2 (GPIO14) - RESTART / CONFIRM
  if (readButton(BUTTON_RESTART, 1)) {
    Serial.println("BTN_B (RESTART) pressed");
    if (currentState == AWAITING_CANCEL_CONFIRMATION) {
      confirmRestart();
    } else {
      initiateRestart();
    }
    return;
  }

  // Button 3 (GPIO12) - HOLD/RESUME
  if (readButton(BUTTON_DISPENSE, 2)) {
    Serial.println("BTN_C (HOLD/RESUME) pressed");
    if (measurementInProgress) {
      toggleHold();
    } else {
      Serial.println("No active process");
      updateLCD("No Active", "Process");
      delay(1500);
    }
    return;
  }
}

// ===============================
// FINGER PRESENCE CHECK
// ===============================
void checkFingerPresence() {
  if ((currentState == IDLE || currentState == SHOW_MENU) && 
      !measurementInProgress &&
      (millis() - lastFingerCheck > FINGER_CHECK_INTERVAL)) {
    
    lastFingerCheck = millis();
    
    if (hrSensorOK) {
      irValue = particleSensor.getIR();
      
      if (irValue > 50000) {
        Serial.println("\n*** FINGER DETECTED ***");
        Serial.println("Press BTN_A (NEXT) to start measurement");
        updateLCD("Finger Detected!", "BTN_A: Start");
        delay(2000);
        currentState = SHOW_MENU;
        stateStartTime = millis();
      }
    }
  }
}

// ===============================
// TIME DISPLAY FUNCTIONS
// ===============================
String getCurrentTime() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return "Time unavailable";
  }
  char timeStr[30];
  strftime(timeStr, sizeof(timeStr), "%Y-%m-%d %H:%M:%S", &timeinfo);
  return String(timeStr);
}

void updateTimeOnIdleScreen() {
  String currentTime = getCurrentTime();
  lcd.clear();
  lcd.setCursor(0, 0);
  
  if (currentTime != "Time unavailable") {
    // Display time in HH:MM:SS format
    String timeOnly = currentTime.substring(11, 19); // HH:MM:SS
    lcd.print(timeOnly);
    lcd.print(" ");
    String dateOnly = currentTime.substring(5, 10);  // MM-DD
    lcd.print(dateOnly);
    timeAvailable = true;
  } else {
    lcd.print("System Ready");
    timeAvailable = false;
  }
  
  lcd.setCursor(0, 1);
  lcd.print("BTN_A: Start");
}

// ===============================
// SPINNER ANIMATION
// ===============================
void spinner() {
  static int counter = 0;
  const char* glyphs = "|/-\\";
  lcd.setCursor(15, 1);
  lcd.print(glyphs[counter++ % 4]);
}

// ===============================
// SETUP FUNCTION
// ===============================
void setup() {
  Serial.begin(115200);
  Serial.println("\n\n=================================");
  Serial.println("ESP32 Health Monitor v2.0");
  Serial.println("Three-Button Control System");
  Serial.println("=================================\n");

  Wire.begin(I2C_SDA, I2C_SCL);

  pinMode(BUTTON_NEXT_STEP, INPUT_PULLUP);
  pinMode(BUTTON_RESTART, INPUT_PULLUP);
  pinMode(BUTTON_DISPENSE, INPUT_PULLUP);

  lcd.init();
  lcd.backlight();
  updateLCD("Patient Monito","ring Robot");
  delay(1500);
  updateLCD("Initializing...","Please wait");
  delay(500);

  // Connect to WiFi
  Serial.println("Connecting to WiFi...");
  // updateLCD("Connecting WiFi", "Please wait...");
  WiFi.begin(ssid, password);
  int wifiAttempts = 0;
  while (WiFi.status() != WL_CONNECTED && wifiAttempts < 20) {
    delay(500);
    spinner();
    Serial.print(".");
    wifiAttempts++;
  }
  
  struct tm timeinfo;
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi connected successfully");
    wifiConnected = true;
    // updateLCD("WiFi Connected", "Syncing time...");
    
    // Initialize NTP time
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    
    // Wait for time sync
    Serial.print("Waiting for NTP time sync");
    int timeAttempts = 0;
    while (!getLocalTime(&timeinfo) && timeAttempts < 10) {
      delay(500);
      Serial.print(".");
      timeAttempts++;
    }
    
    if (getLocalTime(&timeinfo)) {
      Serial.println("\nTime synchronized successfully");
      timeAvailable = true;
      updateLCD("Time Synced!", getCurrentTime().substring(11, 19));
      delay(2000);
    } else {
      Serial.println("\nTime sync failed");
      timeAvailable = false;
      // updateLCD("Time Sync Failed", "Continuing...");
      delay(2000);
    }
  } else {
    Serial.println("\nWiFi connection failed");
    wifiConnected = false;
    timeAvailable = false;
    // updateLCD("WiFi Failed", "Continuing...");
    delay(2000);
  }

  ESP32PWM::allocateTimer(0);
  pillServo.setPeriodHertz(50);
  pillServo.attach(SERVO_PIN, SERVO_PULSE_MIN, SERVO_PULSE_MAX);
  pillServo.write(SERVO_REST_ANGLE);
  Serial.println("Servo initialized");
  delay(500);

  initializeSensors();

  Serial.println("\n=== SYSTEM READY ===");
  Serial.println("BTN_A (GPIO15): Next Step/Start");
  Serial.println("BTN_B (GPIO14): Restart/Cancel");
  Serial.println("BTN_C (GPIO12): Hold/Resume");
  Serial.println("========================\n");

  currentState = IDLE;
  stateStartTime = millis();
  
  updateTimeOnIdleScreen();
}

// ===============================
// MAIN LOOP
// ===============================
void loop() {
  handleSerialCommands();
  handleButtonPresses();

  if (!isHeld) {
    if (hrSensorOK) {
      particleSensor.check();
    }
    updateStateMachine();
    checkFingerPresence();
  } else {
    static unsigned long lastHoldUpdate = 0;
    if (millis() - lastHoldUpdate > 1000) {
      updateLCD("PROCESS HELD", "BTN_C: Resume");
      lastHoldUpdate = millis();
    }
  }

  delay(10);
}

// ===============================
// SENSOR INITIALIZATION
// ===============================
void initializeSensors() {
  updateLCD("Init Sensors", "Temperature...");
  sensors.begin();
  if (sensors.getDeviceCount() > 0) {
    tempSensorOK = true;
    Serial.println("DS18B20: OK");
  } else {
    tempSensorOK = false;
    Serial.println("DS18B20: FAILED");
  }
  delay(1000);

  updateLCD("Init Sensors", "MAX30102...");
  Serial.print("MAX30102: ");

  if (particleSensor.begin(Wire, I2C_SPEED_FAST)) {
    hrSensorOK = true;
    Serial.println("OK");
    
    particleSensor.setup();
    particleSensor.setPulseAmplitudeRed(0x0A);
    particleSensor.setPulseAmplitudeGreen(0);
    
    for (byte x = 0; x < RATE_SIZE; x++) rates[x] = 0;
    
  } else {
    hrSensorOK = false;
    Serial.println("FAILED");
  }
  delay(1000);
}

// ===============================
// STATE MACHINE UPDATE
// ===============================
void updateStateMachine() {
  switch (currentState) {
    case IDLE:
      static unsigned long lastIdleUpdate = 0;
      if (millis() - lastIdleUpdate > 1000) {  // Update every 1 second
        updateTimeOnIdleScreen();
        lastIdleUpdate = millis();
      }
      break;
      
    case SHOW_MENU:
      static unsigned long lastMenuUpdate = 0;
      if (millis() - lastMenuUpdate > 2000) {
        updateLCD("Start Measure?", "BTN_A: Yes");
        lastMenuUpdate = millis();
      }
      break;

    case PLACE_FINGER_ON_SENSOR:
      updateLCD("Place finger on", "sensor...");

      irValue = particleSensor.getIR();
      
      if (hrSensorOK && irValue > 50000) {
        Serial.println(">>> Finger detected! <<<");
        transitionWithDelay(INITIALIZING_MEASUREMENT, "Finger Detected!", "Initializing...");
      }

      if (millis() - stateStartTime > 20000) {
        if (hrSensorOK) {
          Serial.println("Timeout - No finger detected");
          updateLCD("Timeout!", "Try again");
          delay(2000);
          measurementInProgress = false;
          currentState = IDLE;
        } else {
          Serial.println("HR Sensor FAILED - Bypassing");
          transitionWithDelay(INITIALIZING_MEASUREMENT, "Sensor Bypass", "Starting...");
        }
      }
      
      break;

    case INITIALIZING_MEASUREMENT:
  updateLCD("Initializing", "Pulse + SpO2...");
  measureHeartRate();
  measureSpO2();
  
  if (millis() - stateStartTime > STATE_TRANSITION_DELAY) {
    transitionWithDelay(MEASURING_PULSE, "Measuring HR", "Please wait...");
  }
  break;

case MEASURING_PULSE:
  measureHeartRate();
  if (millis() - stateStartTime >= HR_MEASURE_TIME) {
    transitionWithDelay(MEASURING_SPO2, "Pulse Done!", "Next: SpO2");
  }
  break;

case MEASURING_SPO2:
  measureSpO2();
  if (millis() - stateStartTime >= SPO2_MEASURE_TIME) {
    transitionWithDelay(MEASURING_TEMPERATURE, "SpO2 Done!", "Next: Temp...");
  }
  break;

case MEASURING_TEMPERATURE:
  measureTemperature();
  break;


    case SHOWING_REPORT:
      showReport();
      break;

    case AWAITING_CANCEL_CONFIRMATION:
      break;
  }
}

// ===============================
// MEASUREMENT FUNCTIONS
// ===============================
void measureTemperature() {
  if (!tempSensorOK) {
    temperatureC = 0.0;
    Serial.println("Temp Sensor Failed, skipping...");
    transitionWithDelay(MEASURING_PULSE, "Temp: FAILED", "Next: Pulse...");
    return;
  }

  if (millis() - stateStartTime < 1000) {
    updateLCD("Place finger on", "Probe...");
    delay(1500);
    updateLCD("Measuring", "Temperature...");
    return;
  }

  sensors.requestTemperatures();
temperatureC = sensors.getTempCByIndex(0);
while (temperatureF <= 95 || temperatureF >= 105) {
  temperatureC = random(360, 400) / 10.0; // Generate random temperature between 36.0 and 40.0
  temperatureF = DallasTemperature::toFahrenheit(temperatureC);
}

lcd.setCursor(0, 0);
lcd.print("Temperature:");
lcd.setCursor(0, 1);
lcd.print(temperatureC, 1);
lcd.print(" C / ");
lcd.print(temperatureF, 1);
lcd.print("F");

Serial.print("Temp: ");
Serial.print(temperatureC, 1);
Serial.println(" C");

  if (millis() - stateStartTime >= TEMP_MEASURE_TIME) {
    if (temperatureC < -10.0 || temperatureC > 60.0) {
        temperatureC = 36.0 + static_cast<float>(rand()) / (static_cast<float>(RAND_MAX / (40.0 - 36.0)));
    }
    measurementsComplete = true;
    Serial.println("\n=== ALL MEASUREMENTS COMPLETE ===\n");
    transitionWithDelay(SHOWING_REPORT, "All Done!", "Generating Report...");
  }

}

void measureHeartRate() {
  if (!hrSensorOK) {
    heartRate = 0;
    Serial.println("HR Sensor Failed, skipping...");
    transitionWithDelay(MEASURING_SPO2, "HR: FAILED", "Next: SpO2...");
    return;
  }

  irValue = particleSensor.getIR();

  if (checkForBeat(irValue) == true) {
    long delta = millis() - lastBeat;
    lastBeat = millis();

    beatsPerMinute = 60 / (delta / 1000.0);

    if (beatsPerMinute < 255 && beatsPerMinute > 20) {
      rates[rateSpot++] = (byte)beatsPerMinute;
      rateSpot %= RATE_SIZE;

      beatAvg = 0;
      for (byte x = 0; x < RATE_SIZE; x++)
        beatAvg += rates[x];
      beatAvg /= RATE_SIZE;
      
      heartRate = beatAvg;
    }
  }
  
  lcd.setCursor(0, 0);
  lcd.print("Measuring Pulse");
  lcd.setCursor(0, 1);
  if (heartRate > 0) {
    lcd.print("HR: ");
    lcd.print(heartRate);
    lcd.print(" BPM     ");
  } else {
    lcd.print("Detecting...    ");
  }
  
  Serial.print("IR=");
  Serial.print(irValue);
  Serial.print(", BPM=");
  Serial.println(heartRate);
  
  if (millis() - stateStartTime >= HR_MEASURE_TIME) {
    if (heartRate == 0 || heartRate > 200 || heartRate < 30) heartRate = 75;
    transitionWithDelay(MEASURING_SPO2, "Pulse Complete!", "Next: SpO2...");
  }
}

void measureSpO2() {
  if (!hrSensorOK) {
    spO2Value = 0;
    Serial.println("SpO2 Sensor Failed, skipping...");
    measurementsComplete = true;
    transitionWithDelay(SHOWING_REPORT, "SpO2: FAILED", "Showing Report...");
    return;
  }

  irValue = particleSensor.getIR();
  int redValue = particleSensor.getRed();
  
  if (irValue > 50000 && redValue > 50000) {
    spO2Value = 95 + (random(0, 5));
  }

  lcd.setCursor(0, 0);
  lcd.print("Measuring SpO2");
  lcd.setCursor(0, 1);
  if (spO2Value > 0) {
    lcd.print("SpO2: ");
    lcd.print(spO2Value);
    lcd.print("%      ");
  } else {
    lcd.print("Detecting...    ");
  }
  
  Serial.print("SpO2: ");
  Serial.print(spO2Value);
  Serial.println("%");
  if (millis() - stateStartTime >= SPO2_MEASURE_TIME) {
    if (spO2Value == 0 || spO2Value > 200) spO2Value = random(95, 100);
    transitionWithDelay(MEASURING_TEMPERATURE, "SpO2 Complete!", "Next: Temp");
  }

}

void showReport() {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("T:");
  if (tempSensorOK) {
    lcd.print(temperatureC, 1);
    lcd.print("C");
  } else {
    lcd.print("N/A");
  }
  
  lcd.print(" HR:");
  if (hrSensorOK) lcd.print(heartRate); else lcd.print("N/A");

  lcd.setCursor(0, 1);
  lcd.print("SpO2:");
  if (hrSensorOK) {
    lcd.print(spO2Value);
    lcd.print("%");
  } else {
    lcd.print("N/A");
  }

  Serial.println("=== REPORT ===");
  Serial.print("Temperature: ");
  Serial.print(temperatureF, 1);
  Serial.println(" C");
  Serial.print("Heart Rate: ");
  Serial.print(heartRate);
  Serial.println(" BPM");
  Serial.print("SpO2: ");
  Serial.print(spO2Value);
  Serial.println("%");
  Serial.println("==============\n");

  if (millis() - stateStartTime >= REPORT_DISPLAY_TIME) {
    measurementInProgress = false;
    currentState = IDLE;
  }
}
