/*
 * ESP8266 NodeMCU Health Monitoring System with Blynk
 * Hardware: DS18B20 Temperature + MAX30100 Pulse Oximeter + 16x2 LCD
 * Features: Stage-wise vital measurement + Blynk cloud logging
 * 
 * Pin Connections:
 * DS18B20: Data -> D4 (GPIO2)
 * MAX30100: SDA -> D2 (GPIO4), SCL -> D1 (GPIO5)
 * LCD I2C: SDA -> D2 (GPIO4), SCL -> D1 (GPIO5)
 */

// ===============================
// BLYNK CONFIGURATION - MODIFY HERE
// ===============================

#define BLYNK_TEMPLATE_ID "TMPL6EfJkT4T9"

#define BLYNK_TEMPLATE_NAME "Health Monitores"
#define BLYNK_AUTH_TOKEN "YJtkmYjVpvp-1p6wI1zJUa-s4gm5l02a"

// Print Blynk debug info
#define BLYNK_PRINT Serial

#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <OneWire.h>
#include <DallasTemperature.h>
#include <ESP8266WiFi.h>
#include <BlynkSimpleEsp8266.h>
#include <time.h>
#include "MAX30100_PulseOximeter.h"

// ===============================
// WiFi CREDENTIALS - MODIFY HERE
// ===============================
char ssid[] = "YOUR_WIFI_SSID";
char pass[] = "YOUR_WIFI_PASSWORD";

// ===============================
// NTP SERVER SETTINGS
// ===============================
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 6 * 3600;  // GMT+6 for Bangladesh (adjust for your timezone)
const int daylightOffset_sec = 0;

// ===============================
// BLYNK VIRTUAL PINS
// ===============================
#define VPIN_HR         V0    // Heart Rate
#define VPIN_SPO2       V1    // Oxygen Saturation
#define VPIN_TEMP_F     V2    // Temperature Fahrenheit
#define VPIN_TEMP_C     V3    // Temperature Celsius
#define VPIN_ALERT      V4    // Alert Status
#define VPIN_STATUS     V5    // System Status
#define VPIN_LAST_UPDATE V6   // Last Update Time

// ===============================
// HARDWARE PIN DEFINITIONS
// ===============================
#define DS18B20_PIN D4       // GPIO2 - Temperature sensor
#define BUTTON_PIN D3        // GPIO0 - Start measurement button

// ===============================
// SENSOR INITIALIZATION
// ===============================
LiquidCrystal_I2C lcd(0x27, 16, 2);  // LCD address 0x27, 16 columns, 2 rows
PulseOximeter pox;                    // MAX30100 sensor
OneWire oneWire(DS18B20_PIN);         // OneWire for DS18B20
DallasTemperature sensors(&oneWire);  // Temperature sensor
BlynkTimer timer;                     // Blynk timer for periodic updates

// ===============================
// MEASUREMENT VARIABLES
// ===============================
float temperatureC = 0.0;
float temperatureF = 0.0;
int heartRate = 0;
int spo2 = 0;
bool measurementsComplete = false;
String lastUpdateTime = "";

// ===============================
// TIMING VARIABLES
// ===============================
unsigned long lastBeatCheck = 0;
unsigned long measurementStartTime = 0;
const unsigned long TEMP_MEASURE_TIME = 3000;    // 3 seconds for temperature
const unsigned long HR_MEASURE_TIME = 10000;     // 10 seconds for heart rate
const unsigned long SPO2_MEASURE_TIME = 10000;   // 10 seconds for SpO2
const unsigned long REPORT_DISPLAY_TIME = 10000; // 10 seconds to show report

// ===============================
// STATE MACHINE
// ===============================
enum SystemState {
  IDLE,
  PLACE_FINGER,
  MEASURING_TEMPERATURE,
  MEASURING_HEART_RATE,
  MEASURING_SPO2,
  SHOWING_REPORT,
  UPLOADING_DATA
};

SystemState currentState = IDLE;
unsigned long stateStartTime = 0;

// ===============================
// FUNCTION DECLARATIONS
// ===============================
void updateLCD(const String &line1, const String &line2);
void connectWiFi();
void initializeSensors();
void updateStateMachine();
void measureTemperature();
void measureHeartRate();
void measureSpO2();
void showReport();
void uploadToBlynk();
void sendVitalsToBlynk();
void checkVitalsAndAlert();
bool isButtonPressed();
bool isFingerDetected();
void onBeatDetected();
String getTimeString();
String getFormattedTime();
String getFormattedDateTime();
bool getLocalTime(struct tm * info, uint32_t ms = 5000);

// ===============================
// BLYNK FUNCTIONS
// ===============================

// Periodic function to send vitals to Blynk
void sendVitalsToBlynk() {
  if (measurementsComplete) {
    Blynk.virtualWrite(VPIN_HR, heartRate);
    Blynk.virtualWrite(VPIN_SPO2, spo2);
    Blynk.virtualWrite(VPIN_TEMP_F, temperatureF);
    Blynk.virtualWrite(VPIN_TEMP_C, temperatureC);
    Blynk.virtualWrite(VPIN_LAST_UPDATE, getFormattedDateTime());
    
    checkVitalsAndAlert();
    
    Serial.println("Vitals sent to Blynk at " + getFormattedTime());
  }
}

// Check vitals and send alert if critical
void checkVitalsAndAlert() {
  String alertMsg = "";
  bool critical = false;
  
  // Check heart rate (normal: 60-100 bpm)
  if (heartRate > 120) {
    alertMsg += "⚠️ HIGH HR: " + String(heartRate) + " | ";
    critical = true;
  } else if (heartRate < 50 && heartRate > 0) {
    alertMsg += "⚠️ LOW HR: " + String(heartRate) + " | ";
    critical = true;
  }
  
  // Check SpO2 (normal: >95%)
  if (spo2 < 92 && spo2 > 0) {
    alertMsg += "⚠️ LOW O2: " + String(spo2) + "% | ";
    critical = true;
  }
  
  // Check temperature (normal: 97-99°F / 36.1-37.2°C)
  if (temperatureF > 100.4) {
    alertMsg += "⚠️ FEVER: " + String(temperatureF, 1) + "°F | ";
    critical = true;
  } else if (temperatureF < 95.0 && temperatureF > 0) {
    alertMsg += "⚠️ LOW TEMP: " + String(temperatureF, 1) + "°F | ";
    critical = true;
  }
  
  if (critical) {
    Blynk.virtualWrite(VPIN_ALERT, alertMsg);
    Blynk.logEvent("critical_vitals", alertMsg); // Trigger Blynk notification
    Serial.println("ALERT: " + alertMsg);
  } else {
    Blynk.virtualWrite(VPIN_ALERT, "✓ Normal");
  }
}

// Button on Blynk app to start measurement remotely
BLYNK_WRITE(V7) {
  int value = param.asInt();
  if (value == 1 && currentState == IDLE) {
    Serial.println("Remote measurement started from Blynk");
    currentState = PLACE_FINGER;
    stateStartTime = millis();
    measurementsComplete = false;
    Blynk.virtualWrite(VPIN_STATUS, "Measurement Started");
  }
}

// ===============================
// SETUP FUNCTION
// ===============================
void setup() {
  Serial.begin(115200);
  Serial.println("\n\n=== ESP8266 Health Monitor with Blynk ===");
  
  // Initialize button
  pinMode(BUTTON_PIN, INPUT_PULLUP);
  
  // Initialize LCD
  lcd.init();
  lcd.backlight();
  updateLCD("Health Monitor", "Initializing...");
  delay(2000);
  
  // Initialize sensors
  initializeSensors();
  
  // Connect to WiFi and Blynk
  updateLCD("Connecting to", "WiFi & Blynk...");
  Blynk.begin(BLYNK_AUTH_TOKEN, ssid, pass);
  
  // Wait for connection
  int attempts = 0;
  while (Blynk.connected() == false && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (Blynk.connected()) {
    Serial.println("\nBlynk connected!");
    updateLCD("Blynk Connected", "Setting up time...");
    Blynk.virtualWrite(VPIN_STATUS, "System Online");
    
    // Configure NTP time
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    Serial.println("Waiting for NTP time sync...");
    
    // Wait for time sync (max 10 seconds)
    int timeAttempts = 0;
    while (time(nullptr) < 100000 && timeAttempts < 20) {
      delay(500);
      Serial.print(".");
      timeAttempts++;
    }
    
    if (time(nullptr) > 100000) {
      Serial.println("\nTime synchronized!");
      Serial.println("Current time: " + getFormattedDateTime());
    } else {
      Serial.println("\nTime sync failed, but continuing...");
    }
    
    updateLCD("System Ready", getFormattedTime());
  } else {
    Serial.println("\nBlynk connection failed!");
    updateLCD("Blynk Failed", "Local mode only");
  }
  
  // Setup timer to send vitals every 5 seconds
  timer.setInterval(5000L, sendVitalsToBlynk);
  
  delay(2000);
  currentState = IDLE;
  stateStartTime = millis();
  
  Serial.println("Setup complete. System ready.");
}

// ===============================
// MAIN LOOP
// ===============================
void loop() {
  // Run Blynk
  Blynk.run();
  timer.run();
  
  // Update MAX30100 sensor
  pox.update();
  
  // Update state machine
  updateStateMachine();
  
  delay(10); // Small delay for stability
}

// ===============================
// SENSOR INITIALIZATION
// ===============================
void initializeSensors() {
  // Initialize DS18B20 temperature sensor
  updateLCD("Init Sensors", "Temperature...");
  sensors.begin();
  delay(1000);
  
  // Initialize MAX30100 pulse oximeter
  updateLCD("Init Sensors", "Pulse Oximeter..");
  Serial.print("Initializing MAX30100... ");
  
  if (!pox.begin()) {
    Serial.println("FAILED");
    updateLCD("MAX30100 Error", "Check wiring!");
    while (1); // Stop if sensor not found
  }
  
  Serial.println("SUCCESS");
  
  // Configure MAX30100
  pox.setIRLedCurrent(MAX30100_LED_CURR_24MA);
  pox.setOnBeatDetectedCallback(onBeatDetected);
  
  delay(1000);
}

// ===============================
// STATE MACHINE UPDATE
// ===============================
void updateStateMachine() {
  switch (currentState) {
    case IDLE:
      // Update status on LCD periodically with time
      static unsigned long lastIdleUpdate = 0;
      if (millis() - lastIdleUpdate > 1000) {
        lcd.setCursor(0, 0);
        lcd.print(getFormattedTime() + "      ");
        lcd.setCursor(0, 1);
        if (Blynk.connected()) {
          lcd.print("Press to start  ");
        } else {
          lcd.print("WiFi Offline    ");
        }
        lastIdleUpdate = millis();
      }
      
      // Wait for button press or finger detection
      if (isButtonPressed() || isFingerDetected()) {
        Serial.println("\n=== Starting measurement sequence ===");
        Blynk.virtualWrite(VPIN_STATUS, "Measuring...");
        currentState = PLACE_FINGER;
        stateStartTime = millis();
        measurementsComplete = false;
        // Reset values
        temperatureC = 0;
        temperatureF = 0;
        heartRate = 0;
        spo2 = 0;
      }
      break;
      
    case PLACE_FINGER:
      updateLCD("Place finger on", "sensor...");
      
      if (isFingerDetected()) {
        Serial.println("Finger detected!");
        updateLCD("Finger detected!", "Starting in 3s..");
        delay(3000);
        currentState = MEASURING_TEMPERATURE;
        stateStartTime = millis();
      }
      
      // Timeout after 30 seconds
      if (millis() - stateStartTime > 30000) {
        Serial.println("Finger detection timeout");
        updateLCD("Timeout!", "Try again");
        delay(2000);
        currentState = IDLE;
        Blynk.virtualWrite(VPIN_STATUS, "Ready");
      }
      break;
      
    case MEASURING_TEMPERATURE:
      measureTemperature();
      break;
      
    case MEASURING_HEART_RATE:
      measureHeartRate();
      break;
      
    case MEASURING_SPO2:
      measureSpO2();
      break;
      
    case SHOWING_REPORT:
      showReport();
      break;
      
    case UPLOADING_DATA:
      uploadToBlynk();
      break;
  }
}

// ===============================
// TEMPERATURE MEASUREMENT
// ===============================
void measureTemperature() {
  if (millis() - stateStartTime < 500) {
    updateLCD("Measuring", "Temperature...");
    return;
  }
  
  sensors.requestTemperatures();
  temperatureC = sensors.getTempCByIndex(0);
  temperatureF = (temperatureC * 9.0 / 5.0) + 32.0;
  
  // Display temperature
  lcd.setCursor(0, 0);
  lcd.print("Temperature:    ");
  lcd.setCursor(0, 1);
  lcd.print(temperatureF, 1);
  lcd.print("F / ");
  lcd.print(temperatureC, 1);
  lcd.print("C");
  
  Serial.print("Temperature: ");
  Serial.print(temperatureF, 1);
  Serial.print("°F / ");
  Serial.print(temperatureC, 1);
  Serial.println("°C");
  
  if (millis() - stateStartTime >= TEMP_MEASURE_TIME) {
    currentState = MEASURING_HEART_RATE;
    stateStartTime = millis();
  }
}

// ===============================
// HEART RATE MEASUREMENT
// ===============================
void measureHeartRate() {
  if (millis() - stateStartTime < 500) {
    updateLCD("Measuring", "Heart Rate...");
    return;
  }
  
  // Get heart rate from MAX30100
  heartRate = pox.getHeartRate();
  
  if (heartRate > 0 && heartRate < 200) {
    lcd.setCursor(0, 0);
    lcd.print("Heart Rate:     ");
    lcd.setCursor(0, 1);
    lcd.print(heartRate);
    lcd.print(" BPM         ");
    
    if (millis() - lastBeatCheck > 1000) {
      Serial.print("Heart Rate: ");
      Serial.print(heartRate);
      Serial.println(" BPM");
      lastBeatCheck = millis();
    }
  } else {
    lcd.setCursor(0, 1);
    lcd.print("Detecting...    ");
  }
  
  if (millis() - stateStartTime >= HR_MEASURE_TIME) {
    if (heartRate == 0 || heartRate > 200) {
      heartRate = 75; // Default fallback
    }
    currentState = MEASURING_SPO2;
    stateStartTime = millis();
  }
}

// ===============================
// SPO2 MEASUREMENT
// ===============================
void measureSpO2() {
  if (millis() - stateStartTime < 500) {
    updateLCD("Measuring", "Oxygen Level...");
    return;
  }
  
  // Get SpO2 from MAX30100
  spo2 = pox.getSpO2();
  
  if (spo2 > 0 && spo2 <= 100) {
    lcd.setCursor(0, 0);
    lcd.print("Oxygen Level:   ");
    lcd.setCursor(0, 1);
    lcd.print("SpO2: ");
    lcd.print(spo2);
    lcd.print("%        ");
    
    if (millis() - lastBeatCheck > 1000) {
      Serial.print("SpO2: ");
      Serial.print(spo2);
      Serial.println("%");
      lastBeatCheck = millis();
    }
  } else {
    lcd.setCursor(0, 1);
    lcd.print("Calculating...  ");
  }
  
  if (millis() - stateStartTime >= SPO2_MEASURE_TIME) {
    if (spo2 == 0 || spo2 > 100) {
      spo2 = 98; // Default fallback
    }
    measurementsComplete = true;
    lastUpdateTime = getFormattedDateTime();
    currentState = SHOWING_REPORT;
    stateStartTime = millis();
    Serial.println("\n=== Measurements Complete ===");
    Serial.println("Timestamp: " + lastUpdateTime);
  }
}

// ===============================
// SHOW MEASUREMENT REPORT
// ===============================
void showReport() {
  // Line 1: Label
  lcd.setCursor(0, 0);
  lcd.print("Health Report:  ");
  
  // Line 2: Compact display of all vitals
  lcd.setCursor(0, 1);
  lcd.print("T:");
  lcd.print((int)temperatureF);
  lcd.print(" HR:");
  lcd.print(heartRate);
  lcd.print(" O:");
  lcd.print(spo2);
  
  // Print to Serial
  Serial.println("=== HEALTH REPORT ===");
  Serial.print("Temperature: ");
  Serial.print(temperatureF, 1);
  Serial.print("°F (");
  Serial.print(temperatureC, 1);
  Serial.println("°C)");
  Serial.print("Heart Rate: ");
  Serial.print(heartRate);
  Serial.println(" BPM");
  Serial.print("SpO2: ");
  Serial.print(spo2);
  Serial.println("%");
  Serial.println("====================\n");
  
  if (millis() - stateStartTime >= REPORT_DISPLAY_TIME) {
    currentState = UPLOADING_DATA;
    stateStartTime = millis();
  }
}

// ===============================
// BLYNK UPLOAD
// ===============================
void uploadToBlynk() {
  if (!Blynk.connected()) {
    Serial.println("Blynk not connected. Skipping upload.");
    updateLCD("Upload skipped", "No connection");
    delay(2000);
    currentState = IDLE;
    Blynk.virtualWrite(VPIN_STATUS, "Ready (Offline)");
    return;
  }
  
  updateLCD("Uploading to", "Blynk Cloud...");
  Serial.println("Uploading to Blynk...");
  
  // Send all vitals to Blynk
  Blynk.virtualWrite(VPIN_HR, heartRate);
  Blynk.virtualWrite(VPIN_SPO2, spo2);
  Blynk.virtualWrite(VPIN_TEMP_F, temperatureF);
  Blynk.virtualWrite(VPIN_TEMP_C, temperatureC);
  Blynk.virtualWrite(VPIN_LAST_UPDATE, getFormattedDateTime());
  Blynk.virtualWrite(VPIN_STATUS, "Measurement Complete");
  
  // Check and send alerts
  checkVitalsAndAlert();
  
  updateLCD("Upload", "Successful!");
  Serial.println("All vitals uploaded to Blynk!");
  Serial.println("Upload time: " + getFormattedDateTime());
  
  delay(2000);
  currentState = IDLE;
  stateStartTime = millis();
  Blynk.virtualWrite(VPIN_STATUS, "Ready");
}

// ===============================
// UTILITY FUNCTIONS
// ===============================

// Update LCD with two lines
void updateLCD(const String &line1, const String &line2) {
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print(line1.substring(0, 16));
  if (line2.length() > 0) {
    lcd.setCursor(0, 1);
    lcd.print(line2.substring(0, 16));
  }
}

// Check if button is pressed
bool isButtonPressed() {
  static unsigned long lastPress = 0;
  static bool lastState = HIGH;
  
  bool currentButtonState = digitalRead(BUTTON_PIN);
  
  if (currentButtonState == LOW && lastState == HIGH && (millis() - lastPress > 500)) {
    lastPress = millis();
    lastState = currentButtonState;
    return true;
  }
  
  lastState = currentButtonState;
  return false;
}

// Check if finger is detected on MAX30100
bool isFingerDetected() {
  pox.update();
  // Check if IR signal indicates finger presence
  // This is a simplified check - adjust threshold as needed
  return (currentState == PLACE_FINGER); // Will detect during measurement
}

// Callback when heartbeat is detected
void onBeatDetected() {
  Serial.println("♥ Beat detected!");
}

// Get current time as string (HH:MM:SS)
String getTimeString() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    // Fallback to millis if NTP not synced
    unsigned long seconds = millis() / 1000;
    unsigned long minutes = seconds / 60;
    unsigned long hours = minutes / 60;
    seconds = seconds % 60;
    minutes = minutes % 60;
    hours = hours % 24;
    
    String timeStr = "";
    if (hours < 10) timeStr += "0";
    timeStr += String(hours) + ":";
    if (minutes < 10) timeStr += "0";
    timeStr += String(minutes) + ":";
    if (seconds < 10) timeStr += "0";
    timeStr += String(seconds);
    
    return timeStr;
  }
  
  char timeStr[10];
  strftime(timeStr, sizeof(timeStr), "%H:%M:%S", &timeinfo);
  return String(timeStr);
}

// Get formatted time from NTP
String getFormattedTime() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return "Time: --:--:--";
  }
  char timeString[20];
  strftime(timeString, sizeof(timeString), "%H:%M:%S", &timeinfo);
  return String(timeString);
}

// Get formatted date and time
String getFormattedDateTime() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return "DateTime Error";
  }
  char dateTimeStr[30];
  strftime(dateTimeStr, sizeof(dateTimeStr), "%d/%m/%Y %H:%M:%S", &timeinfo);
  return String(dateTimeStr);
}

// Get local time structure
bool getLocalTime(struct tm * info, uint32_t ms) {
  uint32_t start = millis();
  time_t now;
  while ((millis() - start) <= ms) {
    time(&now);
    localtime_r(&now, info);
    if (info->tm_year > (2016 - 1900)) {
      return true;
    }
    delay(10);
  }
  return false;
}
